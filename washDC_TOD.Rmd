---
title: "Transit Oriented Development in Washington DC"
author: "Johnathan Clementi"
date: '9/24/2021'
output:
  html_document:
    keep_md: true
    code_folding: "hide"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction 

Dear policy maker,

If I only had five minutes of your time, here is an issue that I would like you to think about: Transit Oriented Development, specifically in Washington DC.

Transit Oriented Development, or TOD, is the focused development of mixed-use, pedestrian oriented communities around public transportation access points. TOD is an important urban planning tool in that it increases quality of life of constituents by increasing access to amenities while simultaneously increasing ridership, and therefore efficiency of transit systems. For TOD to be effective, it must meet two criteria: scale and land capitalization [1]. The scale at which transit systems run is important to their overall efficiency and effectiveness. Most transit systems in the US operate at a loss on revenue per passenger ride [1]. With scaled TOD comes an increase in population and therefore use of transit systems. Additionally, the areas surrounding transit nodes will become more valuable as people compete for access to transit and other TOD amenities.

To give you an indication of your constituents’’ demand for TOD, we have put together a brief analysis comparing changes in population, income, rent prices, poverty, and crime across spatial (TOD vs non-TOD census tracts) and temporal (2000, 2010, and 2017 census data) axes. We have included all the code used to manipulate the data and create the figures for greater transparency and future replication of this analysis. We hope that this generates more questions than answers, and is used primarily to start the conversation regarding TOD in the District. 


# Retrieving and Wrangling Census, Transit, and Crime Data

#### Load Libraries, Styling Options, and Custom Functions 
```{r setup_package, warning = FALSE, message = FALSE}
rm(list=ls()) ##Clear my objects from memory

library(tidyverse)
library(tidycensus)
library(sf)
library(tmap) # mapping, install if you don't have it
library(kableExtra)
library(rgdal)

options(scipen=999)
options(tigris_class = "sf")

palette5 <- c("#f0f9e8","#bae4bc","#7bccc4","#43a2ca","#0868ac") #colorwheel

mapTheme <- function(base_size = 12) {
  theme(
    text = element_text( color = "black"),
    plot.title = element_text(size = 16,colour = "black"),
    plot.subtitle=element_text(face="italic"),
    plot.caption=element_text(hjust=0),
    axis.ticks = element_blank(),
    panel.background = element_blank(),axis.title = element_blank(),
    axis.text = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(colour = "black", fill=NA, size=2),
    strip.text.x = element_text(size = 14))
}

plotTheme <- function(base_size = 12) {
  theme(
    text = element_text( color = "black"),
    plot.title = element_text(size = 16,colour = "black"),
    plot.subtitle = element_text(face="italic"),
    plot.caption = element_text(hjust=0),
    axis.ticks = element_blank(),
    panel.background = element_blank(),
    panel.grid.major = element_line("grey80", size = 0.1),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(colour = "black", fill=NA, size=2),
    strip.background = element_rect(fill = "grey80", color = "white"),
    strip.text = element_text(size=12),
    axis.title = element_text(size=12),
    axis.text = element_text(size=10),
    plot.background = element_blank(),
    legend.background = element_blank(),
    legend.title = element_text(colour = "black", face = "italic"),
    legend.text = element_text(colour = "black", face = "italic"),
    strip.text.x = element_text(size = 14)
  )
}

qBr <- function(df, variable, rnd) {
  if (missing(rnd)) {
    as.character(quantile(round(df[[variable]],0),
                          c(.01,.2,.4,.6,.8), na.rm=T))
  } else if (rnd == FALSE | rnd == F) {
    as.character(formatC(quantile(df[[variable]],
                 c(.01,.2,.4,.6,.8), na.rm=T), digits = 3))
  }
}

q5 <- function(variable) {as.factor(ntile(variable, 5))}


# We will use the function provided by Dr. Ken Steif in his Public Policy Analytics book:
# Multi-ring Buffer
multipleRingBuffer <- function(inputPolygon, maxDistance, interval) 
{
  #create a list of distances that we'll iterate through to create each ring
  distances <- seq(0, maxDistance, interval)
  #we'll start with the second value in that list - the first is '0'
  distancesCounter <- 2
  #total number of rings we're going to create
  numberOfRings <- floor(maxDistance / interval)
  #a counter of number of rings
  numberOfRingsCounter <- 1
  #initialize an otuput data frame (that is not an sf)
  allRings <- data.frame()
  
  #while number of rings  counteris less than the specified nubmer of rings
  while (numberOfRingsCounter <= numberOfRings) 
  {
    #if we're interested in a negative buffer and this is the first buffer
    #(ie. not distance = '0' in the distances list)
    if(distances[distancesCounter] < 0 & distancesCounter == 2)
    {
      #buffer the input by the first distance
      buffer1 <- st_buffer(inputPolygon, distances[distancesCounter])
      #different that buffer from the input polygon to get the first ring
      buffer1_ <- st_difference(inputPolygon, buffer1)
      #cast this sf as a polygon geometry type
      thisRing <- st_cast(buffer1_, "POLYGON")
      #take the last column which is 'geometry'
      thisRing <- as.data.frame(thisRing[,ncol(thisRing)])
      #add a new field, 'distance' so we know how far the distance is for a give ring
      thisRing$distance <- distances[distancesCounter]
    }
    
    
    #otherwise, if this is the second or more ring (and a negative buffer)
    else if(distances[distancesCounter] < 0 & distancesCounter > 2) 
    {
      #buffer by a specific distance
      buffer1 <- st_buffer(inputPolygon, distances[distancesCounter])
      #create the next smallest buffer
      buffer2 <- st_buffer(inputPolygon, distances[distancesCounter-1])
      #This can then be used to difference out a buffer running from 660 to 1320
      #This works because differencing 1320ft by 660ft = a buffer between 660 & 1320.
      #bc the area after 660ft in buffer2 = NA.
      thisRing <- st_difference(buffer2,buffer1)
      #cast as apolygon
      thisRing <- st_cast(thisRing, "POLYGON")
      #get the last field
      thisRing <- as.data.frame(thisRing$geometry)
      #create the distance field
      thisRing$distance <- distances[distancesCounter]
    }
    
    #Otherwise, if its a positive buffer
    else 
    {
      #Create a positive buffer
      buffer1 <- st_buffer(inputPolygon, distances[distancesCounter])
      #create a positive buffer that is one distance smaller. So if its the first buffer
      #distance, buffer1_ will = 0. 
      buffer1_ <- st_buffer(inputPolygon, distances[distancesCounter-1])
      #difference the two buffers
      thisRing <- st_difference(buffer1,buffer1_)
      #cast as a polygon
      thisRing <- st_cast(thisRing, "POLYGON")
      #geometry column as a data frame
      thisRing <- as.data.frame(thisRing[,ncol(thisRing)])
      #add teh distance
      thisRing$distance <- distances[distancesCounter]
    }  
    
    #rbind this ring to the rest of the rings
    allRings <- rbind(allRings, thisRing)
    #iterate the distance counter
    distancesCounter <- distancesCounter + 1
    #iterate the number of rings counter
    numberOfRingsCounter <- numberOfRingsCounter + 1
  }
  
  #convert the allRings data frame to an sf data frame
  allRings <- st_as_sf(allRings)
}

figCounter <- 1
```


#### Retrieve data from Census Bureau using tidycensus
```{r pullCensus, warning = FALSE, message = FALSE, results='hide'}
# Declare census variables of interest
census_var2000 <- c("P001001", "P006002", "PCT025009", "PCT025050", "P053001", "H056001", "P092001")
census_var2017 <- c("B25026_001E", "B02001_002E", "B15001_009E", "B15001_050E", "B19013_001E", "B25058_001E", "B06012_002E")
# total pop - p001001 or B25026_001E
# median age of males - p006002 (2000) or b02001_002e
# total male: 18-24 w/ bachelors degree - pct025009 or b15001_009e
# total female: 1824 w/ bachelors degree - pct025050 or b15001_050e
# median household income - p053001 or b19013_001e
# median contract rent - h056001 or b25058_001e
# total living in poverty - p092001 or b06012_002e

tractsDC.00 <- get_decennial(geography = "tract",
                                 year = 2000,
                                 variables = census_var2000,
                                 geometry = TRUE,
                                 state = 11999,
                                 output = "wide")


tractsDC.17 <- get_acs(geography = "tract", 
                           variables = census_var2017, 
                           year=2017, 
                           state=11999,
                           geometry=TRUE, 
                           output="wide")

```

#### Wrangle Census Data:
```{r wrangleCensus, results='hide'}
cleanTracts00 <- 
  tractsDC.00 %>%
  dplyr::select( -NAME, -geometry) %>%
  #spread(variable, estimate) %>%
  #st_drop_geometry() %>% #Drop geometry is the new way of removing the sf geometry class from the dataframe
	st_transform('ESRI:102746') %>%
  rename(TotalPop = P001001, 
  			 Whites = P006002, 
  			 MaleBachelors = PCT025009,
         FemaleBachelors = PCT025050, 
  			 MedHHInc = P053001, 
  			 MedRent = H056001,
         TotalPoverty = P092001) %>%
	mutate(MedRentAdjusted = (MedRent * 1.423), # Adjust for inflation
				 pctWhite = ifelse(TotalPop > 0, Whites / TotalPop, 0),
         pctBachelors = ifelse(TotalPop > 0, ((FemaleBachelors + MaleBachelors) / TotalPop), 0),
         pctPoverty = ifelse(TotalPop > 0, TotalPoverty / TotalPop, 0),
         year = "2000") %>%
	mutate(pctPoverty.scaled = pctPoverty * 100,
			 pctBachelors.scaled = pctBachelors * 100,
			 pctWhite.scaled = pctWhite * 100) %>%
  dplyr::select(-Whites,-FemaleBachelors,-MaleBachelors,-TotalPoverty)


cleanTracts17 <- 
	tractsDC.17 %>%
	dplyr::select(-geometry, -B25026_001M, -B02001_002M, -B15001_009M, 
								-B15001_050M, -B19013_001M, -B25058_001M, -B06012_002M) %>% # Remove margin of error columns
	st_transform('ESRI:102746') %>%
  rename(TotalPop = B25026_001E, 
  			 Whites = B02001_002E,
         FemaleBachelors = B15001_050E, 
  			 MaleBachelors = B15001_009E,
         MedHHInc = B19013_001E, 
  			 MedRent = B25058_001E,
         TotalPoverty = B06012_002E) %>%
  #dplyr::select(-NAME, -starts_with("B")) %>%
  mutate(MedRentAdjusted = (MedRent * 1),
  			 pctWhite = ifelse(TotalPop > 0, Whites / TotalPop,0),
         pctBachelors = ifelse(TotalPop > 0, ((FemaleBachelors + MaleBachelors) / TotalPop),0),
         pctPoverty = ifelse(TotalPop > 0, TotalPoverty / TotalPop, 0),
         year = "2017") %>%
	mutate(pctPoverty.scaled = pctPoverty * 100,
				 pctBachelors.scaled = pctBachelors * 100,
				 pctWhite.scaled = pctWhite * 100) %>%
  dplyr::select(-Whites, -FemaleBachelors, -MaleBachelors, -TotalPoverty, -NAME)



allTracts <- rbind(cleanTracts00,cleanTracts17)
```

#### Retrieve & Clean Washington Metro Data
```{r pullMetro, results='hide'}
# Although the Metro extends into multiple counties and cities in Virginia and Maryland, we will only examine stations in DC
metroStops <- st_read("https://opendata.arcgis.com/datasets/54018b7f06b943f2af278bbe415df1de_52.geojson") %>%
	st_transform('ESRI:102746')
metroLines <- st_read("https://opendata.arcgis.com/datasets/a29b9dbb2f00459db2b0c3c56faca297_106.geojson") %>%
	st_transform('ESRI:102746')

# We need to clean up the stops data a bit
# There are some stops in which multiple lines visit the stop. For our case, we will take the first stop listed
metroStops <- 
	metroStops %>%
	mutate(LINE = 
				 	plyr::revalue(LINE, 
						replace = c(
			 				"green, yellow" = "green", 
			 				"grn, yllw, orange, blue, slvr" = "green", 
				 			"red, green, yellow" = "red", 
			 				"red, blue, orange, silver" = "red",
				 			"blue, orange, silver" = "blue",
				 			"orange, blue, silver" = "orange"
					 	)
				 	)
				) 
```

#### Load and clean crime data & additional census data
```{r pullCrime, warning = FALSE, message = FALSE, results='hide'}
# Retrieve 2010 census data
# Note: can use the census_vars2017 for the 2010 ACS - they are the same field identiers
tractsDC.10 <- get_acs(geography = "tract", 
                           variables = census_var2017, 
                           year=2010, 
                           state=11999,
                           geometry=TRUE, 
                           output="wide")

# Clean 2010 ACS data
cleanTracts10 <- 
	tractsDC.10 %>%
	dplyr::select(-geometry, -B25026_001M, -B02001_002M, -B15001_009M, 
								-B15001_050M, -B19013_001M, -B25058_001M, -B06012_002M) %>% # Remove margin of error columns
	st_transform('ESRI:102746') %>%
  rename(TotalPop = B25026_001E, 
  			 Whites = B02001_002E,
         FemaleBachelors = B15001_050E, 
  			 MaleBachelors = B15001_009E,
         MedHHInc = B19013_001E, 
  			 MedRent = B25058_001E,
         TotalPoverty = B06012_002E) %>%
  #dplyr::select(-NAME, -starts_with("B")) %>%
  mutate(MedRentAdjusted = (MedRent * 1),
  			 pctWhite = ifelse(TotalPop > 0, Whites / TotalPop,0),
         pctBachelors = ifelse(TotalPop > 0, ((FemaleBachelors + MaleBachelors) / TotalPop),0),
         pctPoverty = ifelse(TotalPop > 0, TotalPoverty / TotalPop, 0),
         year = "2010") %>%
	mutate(pctPoverty.scaled = pctPoverty * 100,
				 pctBachelors.scaled = pctBachelors * 100,
				 pctWhite.scaled = pctWhite * 100,
				 MedRentAdjusted = MedRent * 1.124) %>% # Adjust for inflation from 2010 to 2017 
  dplyr::select(-Whites, -FemaleBachelors, -MaleBachelors, -TotalPoverty, -NAME)


allTracts10_17 <- rbind(cleanTracts10,cleanTracts17)


# 2010 crime data (earliest available, is 2008, but use 2010 for decenial census)
crime10 <- st_read("https://opendata.arcgis.com/datasets/fdacfbdda7654e06a161352247d3a2f0_34.geojson") %>%
	st_transform('ESRI:102746') %>%
	filter(grepl('THEFT',OFFENSE)) %>%
	mutate(crimeYear = "2010", OFFENSE = "THEFT", crimeCounter = 1) %>%
	dplyr::select(OFFENSE,crimeYear,crimeCounter)

# 2017 crime data (consistent with upper end of census data we are analyzing)
crime17 <- st_read("https://opendata.arcgis.com/datasets/6af5cb8dc38e4bcbac8168b27ee104aa_38.geojson") %>%
	st_transform('ESRI:102746') %>%
	filter(grepl('THEFT',OFFENSE)) %>%
	mutate(crimeYear = "2017", OFFENSE = "THEFT",crimeCounter = 1) %>%
	dplyr::select(OFFENSE,crimeYear,crimeCounter) 

# Place all crime data in same df
allCrime <- rbind(crime10, crime17)
```


# Map Metro Stops & Lines
```{r metroViz}

# Map of Metro Stops
ggplot() + 
  geom_sf(data=st_union(cleanTracts00)) +
  geom_sf(data=metroStops, 
          aes(colour = LINE), 
          show.legend = "point", size= 2) +
  scale_colour_manual(values = c("blue", "green", "orange", "red"), name = "Metro Line") +
  labs(title="Metro Stops", 
       subtitle="Washington DC", 
       caption=paste0("Figure ", figCounter,": Washington DC Metro Station locations, colored by Metro Line\nData from US Census Bureau & Open Data DC")) +
  mapTheme()

figCounter = figCounter + 1 
```

```{r metroLineViz, warning = FALSE, message = FALSE, results='hide'}
# Map of Metro Lines
ggplot() +
	geom_sf(data = cleanTracts00) +
	geom_sf(data = metroLines,
					aes(color = NAME),
					show.legend = "line", size=2
					) +
	scale_color_manual(values = c("blue", "green", "orange", "red", "gray", "yellow"), name = "Metro Line") +
	labs(title = "Metro Lines",
			 subtitle = "Washington DC",
			 caption=paste0("Figure ", figCounter,": Washington DC Metro Lines\nData from US Census Bureau & Open Data DC")
			 ) +
	mapTheme()

```


# Analysis

#### Identifying TOD and Non-TOD Census Tracts:
```{r identTOD, warning = FALSE, message = FALSE}
# First, lets define regions around each stop
# Create 0.5 mile (2640 foot) buffer around each transit station
# 0.5 mile is generally how far people are willing to walk to transportation
stopBuffers <- 
  st_buffer(metroStops, 2640) %>%
    mutate(Legend = "Buffer")
      

# Sometimes those regions overlap, we need to get rid of those overlaps
# Create an sf object with ONLY the unioned buffer
buffer <- 
  st_union(stopBuffers) %>%
    st_sf() %>%
    mutate(Legend = "Unioned Buffer")

# Lets indentify the census tracts that overlap with the station buffered regions
# We will evaluate if the census tract centroid is within the station buffer region

### THIS IS AN INTERMEDIATE STEP AND MAY NOT NEED ITS OWN VARIABLE ###
selectCentroids <-
  st_centroid(cleanTracts00)[buffer,] %>%
  st_drop_geometry() %>%
  left_join(dplyr::select(cleanTracts00, GEOID)) %>%
  st_sf() %>%
  dplyr::select(TotalPop) %>%
  mutate(Selection_Type = "Select by Centroids")


# We want to be able to identify the tracts by whether they are TOD or Non-TOD
# Here we evaluate whether the census tract centroid is within the TOD buffer region
# and appropriately assign it a "TOD" or "Non-TOD" string
allTracts.group <- 
  rbind(
    st_centroid(allTracts)[buffer,] %>%
      st_drop_geometry() %>%
      left_join(allTracts) %>%
      st_sf() %>%
      mutate(TOD = "TOD"),
    st_centroid(allTracts)[buffer, op = st_disjoint] %>%
      st_drop_geometry() %>%
      left_join(allTracts) %>%
      st_sf() %>%
      mutate(TOD = "Non-TOD"))

# For visualization purposes down the line, we will create an sf object
# that has the outline of all TOD census tracts
#Create Outline of TOD Tracts for use in mapping
TOD_region <-
  allTracts.group%>%
    dplyr::select(TOD)%>%
  filter(TOD=="TOD") %>%
  st_union()%>%
      st_sf()

```


# Visualizizing Trends in Census Data:

#### TOD vs Non-TOD tracts across time
```{r viz1TOD}
# Lets visualize and compare the TOD/Non-TOD tracts across time
ggplot(allTracts.group)+
  geom_sf(data = st_union(cleanTracts17))+
  geom_sf(aes(fill = TOD)) +
  scale_fill_manual(values = c("grey80","orange")) +
  labs(title = "TOD and Non-TOD Census Tracts",
       subtitle="Washington DC",
       caption=paste0("Figure ", figCounter,": TOD and Non-TOD census tracts in 2000 and 2017. TOD census tracts are those where the 
                centroid is located within a half-mile of a Metro station\nData from US Census Bureau & Open Data DC")) +
  facet_wrap(~year)+
  mapTheme() 

figCounter = figCounter + 1
```

#### Trends in population across space and time
```{r vizPopTOD}
# Lets visualize and compare total population within the TOD/Non-TOD tracts across time
ggplot(allTracts.group)+
  geom_sf(data = st_union(cleanTracts17))+
	geom_sf(aes(fill = q5(TotalPop)),color="transparent") +
	geom_sf(data = TOD_region, fill="transparent", color ="red", size=0.8)+
  scale_fill_manual(values =  palette5,
  									labels = qBr(allTracts.group, "TotalPop"), 
                    name = "Popluation\n(Quintile Breaks)") +
  labs(title = "Total Population 2000-2017",
       subtitle="Washington DC",
       caption=paste0("Figure ",figCounter, ": Total population by census tract in 2000 and 2017\nData from US Census Bureau & Open Data DC")) +
  facet_wrap(~year)+
  mapTheme() 

figCounter = figCounter + 1
```

#### Trends in median household income across space and time
```{r, vizIncomeTOD}
ggplot(allTracts.group)+
  geom_sf(data = st_union(cleanTracts17))+
	geom_sf(aes(fill = q5(MedHHInc))) +
	geom_sf(data = TOD_region, fill="transparent", color ="red", size=0.8)+
  scale_fill_manual(values =  palette5,
  									labels = qBr(allTracts.group, "MedHHInc"), 
                    name = "Median Household Income\n(Quintile Breaks)") +
  labs(title = "Median Household Income 2000-2017",
       subtitle="Washington DC",
       caption=paste0("Figure ",figCounter, ": Median Household Income by census tract in 2000 and 2017\nData from US Census Bureau & Open Data DC")) +
  facet_wrap(~year)+
  mapTheme()

figCounter = figCounter + 1
```

#### Trends in median rent prices across space and time
```{r vizRentTOD1, warning = FALSE, message = FALSE, results='hide'}
### NOT ADJUSTED FOR INFLATION!!!
ggplot(allTracts.group)+
  geom_sf(data = st_union(cleanTracts17))+
	geom_sf(aes(fill = q5(MedRent))) +
	geom_sf(data = TOD_region, fill="transparent", color ="red", size=0.8)+
  scale_fill_manual(values =  palette5,
  									labels = qBr(allTracts.group, "MedRent"), 
                    name = "Median Rent Price($)\n(Quintile Breaks)") +
  labs(title = "Median Rent Price ($) 2000-2017",
       subtitle="Washington DC",
       caption=paste0("Figure ",figCounter,": Median Rent Price ($) by census tract in 2000 and 2017\nData from US Census Bureau & Open Data DC")) +
  facet_wrap(~year)+
  mapTheme()
```

```{r vizRentTOD2}
### ADJUSTED FOR INFLATION!!!
ggplot(allTracts.group)+
  geom_sf(data = st_union(cleanTracts17))+
	geom_sf(aes(fill = q5(MedRentAdjusted))) +
	geom_sf(data = TOD_region, fill="transparent", color ="red", size=0.8)+
  scale_fill_manual(values =  palette5,
  									labels = qBr(allTracts.group, "MedRentAdjusted"), 
                    name = "Median Rent Price($)\n(Quintile Breaks)") +
  labs(title = "Median Rent Price ($) 2000-2017",
       subtitle="Washington DC",
       caption=paste0("Figure ", figCounter, ": Median Rent Price ($ adjusted for inflation) by census tract in 2000 and 2017\nData from US Census Bureau & Open Data DC")) +
  facet_wrap(~year)+
  mapTheme()

figCounter = figCounter + 1
```


#### Trends in poverty across space and time
```{r vizPovTOD}
ggplot(allTracts.group)+
  geom_sf(data = st_union(cleanTracts17))+
	geom_sf(aes(fill = q5(pctPoverty.scaled))) +
	geom_sf(data = TOD_region, fill="transparent", color ="red", size=0.8)+
  scale_fill_manual(values =  palette5,
  									labels = qBr(allTracts.group, "pctPoverty.scaled"), 
                    name = "Percent People\nin Poverty\n(Quintile Breaks)") +
  labs(title = "Percent People in Poverty 2000-2017",
       subtitle="Washington DC",
       caption=paste0("Figure ", figCounter, ": Percent of population in poverty by census tract in 2000 and 2017\nData from US Census Bureau & Open Data DC")) +
  facet_wrap(~year)+
  mapTheme()

figCounter = figCounter + 1
```

#### Tabulating change in indicators across time and TOD / Non-TOD tracts
```{r tableIndicators, warning = FALSE, message = FALSE}
allTracts.Summary <- 
  st_drop_geometry(allTracts.group) %>%
    group_by(year, TOD) %>%
    summarize(Rent = mean(MedRent, na.rm = T),
              Population = mean(TotalPop, na.rm = T),
              Percent_White = mean(pctWhite, na.rm = T),
              Percent_Bach = mean(pctBachelors, na.rm = T),
              Percent_Poverty = mean(pctPoverty, na.rm = T)
    					) 

allTracts.SummaryTable <-
	allTracts.Summary %>%
  unite(year.TOD, year, TOD, sep = ": ", remove = T) %>%
  gather(Variable, Value, -year.TOD) %>%
  mutate(Value = round(Value, 2)) %>%
  spread(year.TOD, Value)

table1 <- 
	kable(allTracts.SummaryTable) %>%
  kable_styling() %>%
  footnote(general_title = "\n",
           general = "Table 1")

table1

# save_kable(table1,"D:/Users/Johnathan/Google Drive/Grad School/PennDesign_MUSA/PublicPolicyAnalytics/tod_assignment/DC_TransitOrientedDevelopment/table1.png")

```

#### Visualizing change in indicators across time and TOD / Non-TOD tracts
```{r plotIndicators}
plotCounter <- 1

allTracts.SummaryPlot <-
	allTracts.Summary %>%
  gather(Variable, Value, -year, -TOD) %>%
  ggplot(aes(year, Value, fill = TOD)) +
    geom_bar(stat = "identity", position = "dodge") +
    facet_wrap(~Variable, scales = "free", ncol=5) +
    scale_fill_manual(values = c("#bae4bc", "#0868ac")) +
    labs(title = "Indicator differences across time and space",
    		 subtitle="Washington DC",
    		 caption=paste0("Plot ", plotCounter, ". Data from US Census Bureau")) +
    plotTheme() + theme(legend.position="bottom")

allTracts.SummaryPlot

plotCounter = plotCounter + 1
```

#### Visualizing change in population within 0.5 miles of a metro stop
```{r vizPopStops, warning = FALSE, message = FALSE}

# Lets find the intersecting regions of the tracts and our previously created 0.5 mile regions around the metro stops
station_tracts <- st_intersection(allTracts, stopBuffers)

# Lets summarize those data so we can join it back to the station points and visualize it
station_summary <-
	station_tracts %>%
	st_drop_geometry() %>%
	group_by(year, GIS_ID) %>%
	summarize(Population = sum(TotalPop),
						Rent = mean(MedRent, na.rm = T)
						) %>%
	filter()

# Complete the join of the summarized data to the station points
station_GeoSummary <-
	left_join(metroStops, station_summary, by = "GIS_ID") %>%
	dplyr::select(-WEB_URL, -TRAININFO_URL)

# Now that we have the data ready, lets visualize it

# Graduated Symbols map visualizing population
ggplot(station_GeoSummary) +
	geom_sf(data = allTracts)+
	geom_sf(aes(size = Population), color = "#7bccc4") +
  labs(title = "Population with access to Metro stops 2000-2017",
       subtitle="Washington DC",
       caption=paste0("Figure ", figCounter, ": total population within 0.5 mile walking distance of a metro stop in 2000 and 2017\nData from US Census Bureau & Open Data DC")) +
	facet_wrap(~year) +
	mapTheme()

figCounter = figCounter + 1

# Graduated Symbols map visualizing rent
ggplot(station_GeoSummary) +
	geom_sf(data = allTracts)+
	geom_sf(aes(size = Rent), color = "#43a2ca") +
	labs(title = "Rent prices near Metro stops 2000-2017",
       subtitle="Washington DC",
       caption=paste0("Figure ", figCounter, ": Average rent price ($) for homes within 0.5 mile walking distance of a metro stop in 2000 and 2017\nData from US Census Bureau & Open Data DC")) +
	facet_wrap(~year) +
	mapTheme()

figCounter = figCounter + 1
```

#### Visualizing change in rent as a function of distance from metro stations

```{r vizMRB}
coolRingBuffer <- multipleRingBuffer(st_union(metroStops), 37830, 2640)

ggplot(coolRingBuffer) + 
  geom_sf(data=coolRingBuffer, 
          aes(colour = distance), 
          show.legend = "polygon", size= 2) +
  scale_colour_gradient() +
	geom_sf(data=st_union(cleanTracts00), fill="transparent", color="red",size =1) +
  labs(title="Metro Stops", 
       subtitle="District of Columbia", 
       caption=paste0("Figure ", figCounter, ": 2640ft (0.5 mile) rings around DC metro stops\nData from US Census Bureau & Open Data DC")) +
  mapTheme()
		
```
	
	
```{r plotRentDistStop, warning = FALSE, message = FALSE}
# Use multipleRingBuffer to draw regions around the metro stops
# Then join the census data (containing rent data) to those rings
allTracts.rings <-
  st_join(st_centroid(dplyr::select(allTracts, GEOID, year)), 
          multipleRingBuffer(st_union(metroStops), 37830, 2640)) %>%
  st_drop_geometry() %>%
  left_join(dplyr::select(allTracts, GEOID, MedRentAdjusted, year), 
            by=c("GEOID"="GEOID", "year"="year")) %>%
  st_sf() %>%
  mutate(distance = distance / 5280) #convert to miles

# Lets clean up the data so we can visualize it as a line graph
# We need to get rid of the geometry, group by year and distance
# and then summarize the rents found at each level (calculate avg)
allTracts.rings.summary <-
	allTracts.rings %>%
	st_drop_geometry() %>%
	group_by(distance, year) %>%
	summarize(Rent = mean(MedRentAdjusted, na.rm = TRUE)) %>%
	mutate(Rent = round(Rent, 2))

# Now let's visualize it
ggplot(allTracts.rings.summary,
			 aes(x =distance, y=Rent, color=year)) +
	geom_line() +
	geom_point() +
	labs(title = "Rent price as a function of distance from Metro stop",
    		 subtitle="Washington DC",
    		 caption=paste0("Plot ", plotCounter, ". Rent price ($) for homes at a certain distance from Metro stops\nRent price adjusted for inflation\nData from US Census Bureau")) +
    plotTheme() + theme(legend.position="bottom")

plotCounter = plotCounter + 1
```

# Trends in Crime, Transit, and Rent

#### Associate crime data with TOD tracts
```{r wrangleCrime, warning = FALSE, message = FALSE}
# Intersect crimes with the station buffer/census tracts from 2010 & 2017 (instead of station_tracts which is 2000 & 2017)
station_tracts10_17 <- st_intersection(allTracts10_17, stopBuffers)


crime_station_tracts <- st_join(station_tracts10_17, allCrime) %>%
	filter(year == crimeYear) %>%
	dplyr::select(GEOID, year, MedRentAdjusted, GIS_ID, crimeYear, OFFENSE, crimeCounter)

# Lets summarize those data so we can join it back to the station points and visualize it
rent_crime_byStation <-
	crime_station_tracts %>%
	st_drop_geometry() %>%
	group_by(year, GIS_ID) %>%
	summarize(Rent = mean(MedRentAdjusted, na.rm = T),
						Thefts = sum(crimeCounter)
						) %>%
	filter()

# Complete the join of the summarized data to the station points
rentCrime_GeoByStation <-
	left_join(metroStops, rent_crime_byStation, by = "GIS_ID") %>%
	dplyr::select(-WEB_URL, -TRAININFO_URL)

```


```{r vizCrime}
# Now that we have the data ready, lets visualize it

# Graduated Symbols map visualizing rent
ggplot(rentCrime_GeoByStation) +
	geom_sf(data = allTracts10_17) +
	geom_sf(aes(size = Rent), color = "#43a2ca") +
	labs(title = "Rent prices near Metro stops 2010-2017",
       subtitle="Washington DC",
       caption=paste0("Figure ", figCounter, ": Average rent price ($) for homes within 0.5 mile walking distance of a metro stop in 2010 and 2017\nRent price adjusted for inflation\nData from US Census Bureau & Open Data DC")) +
	facet_wrap(~year) +
	mapTheme()

figCounter = figCounter + 1

# Graduated Symbols map visualizing crime 
ggplot(rentCrime_GeoByStation) +
	geom_sf(data = allTracts10_17)+
	geom_sf(aes(size = Thefts), color = "#0868ac") +
	labs(title = "Crime rates near Metro stops 2010-2017",
       subtitle="Washington DC",
       caption=paste0("Figure ", figCounter, ": Number of crimes within 0.5 mile walking distance of a metro stop in 2010 and 2017\nData from US Census Bureau & Open Data DC")) +
	facet_wrap(~year) +
	mapTheme()

figCounter = figCounter + 1
```

#### Tabulate differenes in crime & rend across TOD / Non-TOD tracts
```{r tableCrime, warning = FALSE, message = FALSE}
# Identify 2010 & 2017 tracts by TOD & Non-TOD
allTracts10_17.group <- 
  rbind(
    st_centroid(allTracts10_17)[buffer,] %>%
      st_drop_geometry() %>%
      left_join(allTracts10_17) %>%
      st_sf() %>%
      mutate(TOD = "TOD"),
    st_centroid(allTracts10_17)[buffer, op = st_disjoint] %>%
      st_drop_geometry() %>%
      left_join(allTracts10_17) %>%
      st_sf() %>%
      mutate(TOD = "Non-TOD"))

# For comparison of rent and crime within TOD & Non-TOD, join crime data to allTracts df for 2010 & 2017
crime_tracts <- st_join(allTracts10_17.group, allCrime) %>%
	filter(year == crimeYear) %>%
	dplyr::select(GEOID, year, MedRentAdjusted, TOD, crimeYear, OFFENSE, crimeCounter)

# Summarize tracts by total crimes and avg rent per year
crime_tracts.summary <-
	st_drop_geometry(crime_tracts) %>%
	group_by(year, TOD) %>%
	summarize(Rent = mean(MedRentAdjusted, na.rm = T),
						Thefts = sum(crimeCounter, na.rm = T)
						)

# Clean up summary 
crimeTracts.SummaryTable <-
	crime_tracts.summary %>%
  unite(year.TOD, year, TOD, sep = ": ", remove = T) %>%
  gather(Variable, Value, -year.TOD) %>%
  mutate(Value = round(Value, 2)) %>%
  spread(year.TOD, Value)

# Print nice kable table
table2 <- 
	kable(crimeTracts.SummaryTable) %>%
  kable_styling() %>%
  footnote(general_title = "\n",
           general = "Table 2")

table2
```


#### Visualizing change in rent and crime indicators across time and TOD / Non-TOD tracts
```{r plotCrime}
crimeTracts.SummaryPlot <-
	crime_tracts.summary %>%
  gather(Variable, Value, -year, -TOD) %>%
  ggplot(aes(year, Value, fill = TOD)) +
    geom_bar(stat = "identity", position = "dodge") +
    facet_wrap(~Variable, scales = "free", ncol=5) +
    scale_fill_manual(values = c("#bae4bc", "#0868ac")) +
    labs(title = "Crime rates and rent prices in TOD vs non-TOD tracts",
    		 subtitle="Washington DC",
       caption=paste0("Plot ", plotCounter, ". Data from US Census Bureau & Open Data DC")) +
    plotTheme() + theme(legend.position="bottom")

crimeTracts.SummaryPlot
```

