---
title: "Transit Oriented Development in the District of Columbia"
author: "Johnathan Clementi"
date: '9/24/2021'
output:
  html_document:
    keep_md: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction 
Purpose: Prepare a policy brief for local City Council representatives. Do households value transit-rich neighborhoods compared to others? How certain can you be about your conclusions given some of the spatial biases weâ€™ve discussed?

Details: Provide a brief motivation at the beginning, annotate each visualization appropriately, and then provide brief policy-relevant conclusions. Please show all code blocks. Here are the specific deliverables:

1. Show your data wrangling work.
2. Four small-multiple (2000 & 2017+) visualizations comparing four selected Census variables across time and space (TOD vs. non-TOD).
3. One grouped bar plot making these same comparisons.
4. One table making these same comparisons.
5. Create two graduated symbol maps of population and rent within 0.5 mile of each transit station. Google for more information, but a graduate symbol map represents quantities for each transit station proportionally.
6. Create a geom_line plot that shows mean rent as a function of distance to subway stations (Figure 1.17). To do this you will need to use the multipleRingBuffer function found in the functions.R script.
7. Download and wrangle point-level crime data (pick a crime type). What is the relationship between crime, transit access and rents?


# Setup

#### Load Libraries
```{r setup_package, warning = FALSE, message = FALSE}
rm(list=ls()) ##Clear my objects from memory

library(tidyverse)
library(tidycensus)
library(sf)
library(tmap) # mapping, install if you don't have it
library(kableExtra)
library(rgdal)

options(scipen=999)
options(tigris_class = "sf")

palette5 <- c("#f0f9e8","#bae4bc","#7bccc4","#43a2ca","#0868ac") #colorwheel
```

#### Load Styling Options
```{r}
mapTheme <- function(base_size = 12) {
  theme(
    text = element_text( color = "black"),
    plot.title = element_text(size = 16,colour = "black"),
    plot.subtitle=element_text(face="italic"),
    plot.caption=element_text(hjust=0),
    axis.ticks = element_blank(),
    panel.background = element_blank(),axis.title = element_blank(),
    axis.text = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(colour = "black", fill=NA, size=2),
    strip.text.x = element_text(size = 14))
}

plotTheme <- function(base_size = 12) {
  theme(
    text = element_text( color = "black"),
    plot.title = element_text(size = 16,colour = "black"),
    plot.subtitle = element_text(face="italic"),
    plot.caption = element_text(hjust=0),
    axis.ticks = element_blank(),
    panel.background = element_blank(),
    panel.grid.major = element_line("grey80", size = 0.1),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(colour = "black", fill=NA, size=2),
    strip.background = element_rect(fill = "grey80", color = "white"),
    strip.text = element_text(size=12),
    axis.title = element_text(size=12),
    axis.text = element_text(size=10),
    plot.background = element_blank(),
    legend.background = element_blank(),
    legend.title = element_text(colour = "black", face = "italic"),
    legend.text = element_text(colour = "black", face = "italic"),
    strip.text.x = element_text(size = 14)
  )
}
```
#### Load distribution break functions
```{r}
qBr <- function(df, variable, rnd) {
  if (missing(rnd)) {
    as.character(quantile(round(df[[variable]],0),
                          c(.01,.2,.4,.6,.8), na.rm=T))
  } else if (rnd == FALSE | rnd == F) {
    as.character(formatC(quantile(df[[variable]],
                 c(.01,.2,.4,.6,.8), na.rm=T), digits = 3))
  }
}

q5 <- function(variable) {as.factor(ntile(variable, 5))}
```



# Retrieving and Wrangling Census, Transit, and Crime Data

#### Retrieve data from Census Bureau using tidycensus
```{r}
# Declare census variables of interest
census_var2000 <- c("P001001", "P006002", "PCT025009", "PCT025050", "P053001", "H056001", "P092001")
census_var2017 <- c("B25026_001E", "B02001_002E", "B15001_009E", "B15001_050E", "B19013_001E", "B25058_001E", "B06012_002E")
# total pop - p001001 or B25026_001E
# median age of males - p006002 (2000) or b02001_002e
# total male: 18-24 w/ bachelors degree - pct025009 or b15001_009e
# total female: 1824 w/ bachelors degree - pct025050 or b15001_050e
# median household income - p053001 or b19013_001e
# median contract rent - h056001 or b25058_001e
# total living in poverty - p092001 or b06012_002e

# Note: can use the census_vars2017 for the 2010 ACS - they are the same field identiers

tractsDC.00 <- get_decennial(geography = "tract",
                                 year = 2000,
                                 variables = census_var2000,
                                 geometry = TRUE,
                                 state = 11999,
                                 output = "wide")

tractsDC.10 <- get_acs(geography = "tract", 
                           variables = census_var2017, 
                           year=2010, 
                           state=11999,
                           geometry=TRUE, 
                           output="wide")

tractsDC.17 <- get_acs(geography = "tract", 
                           variables = census_var2017, 
                           year=2017, 
                           state=11999,
                           geometry=TRUE, 
                           output="wide")

```

#### Wrangle Census Data:
```{r}
cleanTracts00 <- 
  tractsDC.00 %>%
  dplyr::select( -NAME, -geometry) %>%
  #spread(variable, estimate) %>%
  #st_drop_geometry() %>% #Drop geometry is the new way of removing the sf geometry class from the dataframe
	st_transform('ESRI:102746') %>%
  rename(TotalPop = P001001, 
  			 Whites = P006002, 
  			 MaleBachelors = PCT025009,
         FemaleBachelors = PCT025050, 
  			 MedHHInc = P053001, 
  			 MedRent = H056001,
         TotalPoverty = P092001) %>%
	mutate(MedRentAdjusted = (MedRent * 1.423), # Adjust for inflation
				 pctWhite = ifelse(TotalPop > 0, Whites / TotalPop, 0),
         pctBachelors = ifelse(TotalPop > 0, ((FemaleBachelors + MaleBachelors) / TotalPop), 0),
         pctPoverty = ifelse(TotalPop > 0, TotalPoverty / TotalPop, 0),
         year = "2000") %>%
	mutate(pctPoverty.scaled = pctPoverty * 100,
			 pctBachelors.scaled = pctBachelors * 100,
			 pctWhite.scaled = pctWhite * 100) %>%
  dplyr::select(-Whites,-FemaleBachelors,-MaleBachelors,-TotalPoverty)


cleanTracts17 <- 
	tractsDC.17 %>%
	dplyr::select(-geometry, -B25026_001M, -B02001_002M, -B15001_009M, 
								-B15001_050M, -B19013_001M, -B25058_001M, -B06012_002M) %>% # Remove margin of error columns
	st_transform('ESRI:102746') %>%
  rename(TotalPop = B25026_001E, 
  			 Whites = B02001_002E,
         FemaleBachelors = B15001_050E, 
  			 MaleBachelors = B15001_009E,
         MedHHInc = B19013_001E, 
  			 MedRent = B25058_001E,
         TotalPoverty = B06012_002E) %>%
  #dplyr::select(-NAME, -starts_with("B")) %>%
  mutate(MedRentAdjusted = (MedRent * 1),
  			 pctWhite = ifelse(TotalPop > 0, Whites / TotalPop,0),
         pctBachelors = ifelse(TotalPop > 0, ((FemaleBachelors + MaleBachelors) / TotalPop),0),
         pctPoverty = ifelse(TotalPop > 0, TotalPoverty / TotalPop, 0),
         year = "2017") %>%
	mutate(pctPoverty.scaled = pctPoverty * 100,
				 pctBachelors.scaled = pctBachelors * 100,
				 pctWhite.scaled = pctWhite * 100) %>%
  dplyr::select(-Whites, -FemaleBachelors, -MaleBachelors, -TotalPoverty, -NAME)



allTracts <- rbind(cleanTracts00,cleanTracts17)


```

#### Retrieve & Clean Washington Metro Data
```{r}
# Although the Metro extends into multiple counties and cities in Virginia and Maryland, we will only examine stations in DC
metroStops <- st_read("https://opendata.arcgis.com/datasets/54018b7f06b943f2af278bbe415df1de_52.geojson")
metroLines <- st_read("https://opendata.arcgis.com/datasets/a29b9dbb2f00459db2b0c3c56faca297_106.geojson")

# We need to clean up the stops data a bit
# There are some stops in which multiple lines visit the stop. For our case, we will take the first stop listed
metroStops <- 
	metroStops %>%
	mutate(LINE = 
				 	plyr::revalue(LINE, 
						replace = c(
			 				"green, yellow" = "green", 
			 				"grn, yllw, orange, blue, slvr" = "green", 
				 			"red, green, yellow" = "red", 
			 				"red, blue, orange, silver" = "red",
				 			"blue, orange, silver" = "blue",
				 			"orange, blue, silver" = "orange"
					 	)
				 	)
				) %>%
	st_transform('ESRI:102746')

metroLines <-
	metroLines %>%
	st_transform('ESRI:102746')
	

```

# Map Metro Stops & Lines
```{r}

# Map of Metro Stops
ggplot() + 
  geom_sf(data=st_union(cleanTracts00)) +
  geom_sf(data=metroStops, 
          aes(colour = LINE), 
          show.legend = "point", size= 2) +
  scale_colour_manual(values = c("blue", "green", "orange", "red"), name = "Metro Line") +
  labs(title="Metro Stops", 
       subtitle="District of Columbia", 
       caption="Figure 1: Washington DC Metro Station locations, colored by Metro Line") +
  mapTheme()

# Map of Metro Lines
ggplot() +
	geom_sf(data = cleanTracts00) +
	geom_sf(data = metroLines,
					aes(color = NAME),
					show.legend = "line", size=2
					) +
	scale_color_manual(values = c("blue", "green", "orange", "red", "gray", "yellow"), name = "Metro Line") +
	labs(title = "Metro Lines",
			 subtitle = "District of Columbia",
			 ) +
	mapTheme()
```


# Analysis

#### Identifying TOD and Non-TOD Census Tracts:
```{r}
# First, lets define regions around each stop
# Create 0.5 mile (2640 foot) buffer around each transit station
# 0.5 mile is generally how far people are willing to walk to transportation
stopBuffers <- 
  st_buffer(metroStops, 2640) %>%
    mutate(Legend = "Buffer")
      

# Sometimes those regions overlap, we need to get rid of those overlaps
# Create an sf object with ONLY the unioned buffer
buffer <- 
  st_union(stopBuffers) %>%
    st_sf() %>%
    mutate(Legend = "Unioned Buffer")

# Lets indentify the census tracts that overlap with the station buffered regions
# We will evaluate if the census tract centroid is within the station buffer region

### THIS IS AN INTERMEDIATE STEP AND MAY NOT NEED ITS OWN VARIABLE ###
selectCentroids <-
  st_centroid(cleanTracts00)[buffer,] %>%
  st_drop_geometry() %>%
  left_join(dplyr::select(cleanTracts00, GEOID)) %>%
  st_sf() %>%
  dplyr::select(TotalPop) %>%
  mutate(Selection_Type = "Select by Centroids")



# We want to be able to identify the tracts by whether they are TOD or Non-TOD
# Here we evaluate whether the census tract centroid is within the TOD buffer region
# and appropriately assign it a "TOD" or "Non-TOD" string
allTracts.group <- 
  rbind(
    st_centroid(allTracts)[buffer,] %>%
      st_drop_geometry() %>%
      left_join(allTracts) %>%
      st_sf() %>%
      mutate(TOD = "TOD"),
    st_centroid(allTracts)[buffer, op = st_disjoint] %>%
      st_drop_geometry() %>%
      left_join(allTracts) %>%
      st_sf() %>%
      mutate(TOD = "Non-TOD"))

# For visualization purposes down the line, we will create an sf object
# that has the outline of all TOD census tracts
#Create Outline of TOD Tracts for use in mapping
TOD_region <-
  allTracts.group%>%
    dplyr::select(TOD)%>%
  filter(TOD=="TOD") %>%
  st_union()%>%
      st_sf()

```


# Visualizizing Trends in Census Data:

#### TOD vs Non-TOD tracts across time
```{r}

# Lets visualize and compare the TOD/Non-TOD tracts across time
ggplot(allTracts.group)+
  geom_sf(data = st_union(cleanTracts17))+
  geom_sf(aes(fill = TOD)) +
  scale_fill_manual(values = c("grey80","red")) +
  labs(title = "TOD and Non-TOD Census Tracts",
       subtitle="Washington DC",
       caption="Figure 2: TOD and Non-TOD census tracts in 2000 and 2017. TOD census tracts are those where the 
                centroid is located within a half-mile of a Metro station") +
  facet_wrap(~year)+
  mapTheme() 

```

#### Population trends across space and time
```{r}

# Here we're just looking at Total Population with quantile breaks
ggplot() +
  geom_sf(data = cleanTracts00, aes(fill = q5(TotalPop))) +
  scale_fill_manual(values = palette5,
  									labels = qBr(cleanTracts00, "TotalPop"), 
                    name = "Popluation\n(Quintile Breaks)") +
  labs(title = "Total Population", subtitle = "District of Columbia; 2000") +
  mapTheme()

# Lets visualize and compare total population within the TOD/Non-TOD tracts across time
ggplot(allTracts.group)+
  geom_sf(data = st_union(cleanTracts17))+
	geom_sf(aes(fill = q5(TotalPop)),color="transparent") +
	geom_sf(data = TOD_region, fill="transparent", color ="red", size=0.8)+
  scale_fill_manual(values =  palette5,
  									labels = qBr(allTracts.group, "TotalPop"), 
                    name = "Popluation\n(Quintile Breaks)") +
  labs(title = "Total Population 2000-2017",
       subtitle="Washington DC",
       caption="Figure 3: Total population by census tract in 2000 and 2017") +
  facet_wrap(~year)+
  mapTheme() 

```

#### Trends in median household income across space and time
```{r}
ggplot(allTracts.group)+
  geom_sf(data = st_union(cleanTracts17))+
	geom_sf(aes(fill = q5(MedHHInc))) +
	geom_sf(data = TOD_region, fill="transparent", color ="red", size=0.8)+
  scale_fill_manual(values =  palette5,
  									labels = qBr(allTracts.group, "MedHHInc"), 
                    name = "Median Household Income\n(Quintile Breaks)") +
  labs(title = "Median Household Income 2000-2017",
       subtitle="Washington DC",
       caption="Figure 3: Median Household Income by census tract in 2000 and 2017") +
  facet_wrap(~year)+
  mapTheme()
```

#### Trends in median rent prices across space and time
```{r}
### NOT ADJUSTED FOR INFLATION!!!
ggplot(allTracts.group)+
  geom_sf(data = st_union(cleanTracts17))+
	geom_sf(aes(fill = q5(MedRent))) +
	geom_sf(data = TOD_region, fill="transparent", color ="red", size=0.8)+
  scale_fill_manual(values =  palette5,
  									labels = qBr(allTracts.group, "MedRent"), 
                    name = "Median Rent Price($)\n(Quintile Breaks)") +
  labs(title = "Median Rent Price ($) 2000-2017",
       subtitle="Washington DC",
       caption="Figure 3: Median Rent Price ($) by census tract in 2000 and 2017") +
  facet_wrap(~year)+
  mapTheme()

### ADJUSTED FOR INFLATION!!!
ggplot(allTracts.group)+
  geom_sf(data = st_union(cleanTracts17))+
	geom_sf(aes(fill = q5(MedRentAdjusted))) +
	geom_sf(data = TOD_region, fill="transparent", color ="red", size=0.8)+
  scale_fill_manual(values =  palette5,
  									labels = qBr(allTracts.group, "MedRentAdjusted"), 
                    name = "Median Rent Price($)\n(Quintile Breaks)") +
  labs(title = "Median Rent Price ($) 2000-2017",
       subtitle="Washington DC",
       caption="Figure 3: Median Rent Price ($) by census tract in 2000 and 2017") +
  facet_wrap(~year)+
  mapTheme()
```


#### Trends in poverty across space and time
```{r}
ggplot(allTracts.group)+
  geom_sf(data = st_union(cleanTracts17))+
	geom_sf(aes(fill = q5(pctPoverty.scaled))) +
	geom_sf(data = TOD_region, fill="transparent", color ="red", size=0.8)+
  scale_fill_manual(values =  palette5,
  									labels = qBr(allTracts.group, "pctPoverty.scaled"), 
                    name = "Percent People\nin Poverty\n(Quintile Breaks)") +
  labs(title = "Percent People in Poverty 2000-2017",
       subtitle="Washington DC",
       caption="Figure 3: Percent of population in poverty by census tract in 2000 and 2017") +
  facet_wrap(~year)+
  mapTheme()
```

#### Tabulating change in indicators across time and TOD / Non-TOD tracts
```{r}
allTracts.Summary <- 
  st_drop_geometry(allTracts.group) %>%
    group_by(year, TOD) %>%
    summarize(Rent = mean(MedRent, na.rm = T),
              Population = mean(TotalPop, na.rm = T),
              Percent_White = mean(pctWhite, na.rm = T),
              Percent_Bach = mean(pctBachelors, na.rm = T),
              Percent_Poverty = mean(pctPoverty, na.rm = T)
    					) 

allTracts.SummaryTable <-
	allTracts.Summary %>%
  unite(year.TOD, year, TOD, sep = ": ", remove = T) %>%
  gather(Variable, Value, -year.TOD) %>%
  mutate(Value = round(Value, 2)) %>%
  spread(year.TOD, Value)

table1 <- 
	kable(allTracts.SummaryTable) %>%
  kable_styling() %>%
  footnote(general_title = "\n",
           general = "Table 1.3")

table1

# save_kable(table1,"D:/Users/Johnathan/Google Drive/Grad School/PennDesign_MUSA/PublicPolicyAnalytics/tod_assignment/DC_TransitOrientedDevelopment/table1.png")

```

#### Visualizing change in indicators across time and TOD / Non-TOD tracts
```{r}
allTracts.SummaryPlot <-
	allTracts.Summary %>%
  gather(Variable, Value, -year, -TOD) %>%
  ggplot(aes(year, Value, fill = TOD)) +
    geom_bar(stat = "identity", position = "dodge") +
    facet_wrap(~Variable, scales = "free", ncol=5) +
    scale_fill_manual(values = c("#bae4bc", "#0868ac")) +
    labs(title = "Indicator differences across time and space") +
    plotTheme() + theme(legend.position="bottom")

allTracts.SummaryPlot
```

#### Visualizing change in population within 0.5 miles of a metro stop
```{r}

# Lets find the intersecting regions of the tracts and our previously created 0.5 mile regions around the metro stops
station_tracts <- st_intersection(allTracts, stopBuffers)

# Lets summarize those data so we can join it back to the station points and visualize it
station_summary <-
	station_tracts %>%
	st_drop_geometry() %>%
	group_by(year, GIS_ID) %>%
	summarize(Population = sum(TotalPop),
						Rent = mean(MedRent, na.rm = T)
						) %>%
	filter()

# Complete the join of the summarized data to the station points
station_GeoSummary <-
	left_join(metroStops, station_summary, by = "GIS_ID") %>%
	dplyr::select(-WEB_URL, -TRAININFO_URL)

# Now that we have the data ready, lets visualize it

# Graduated Symbols map visualizing population
ggplot(station_GeoSummary) +
	geom_sf(data = allTracts)+
	geom_sf(aes(size = Population), color = "#7bccc4", ) +
	facet_wrap(~year) +
	mapTheme()

# Graduated Symbols map visualizing rent
ggplot(station_GeoSummary) +
	geom_sf(data = allTracts)+
	geom_sf(aes(size = Rent), color = "#43a2ca", ) +
	facet_wrap(~year) +
	mapTheme()

```

#### Visualizing change in rent as a function of distance from metro stations
```{r}
# We will use the function provided by Dr. Ken Steif in his Public Policy Analytics book:
# Multi-ring Buffer
multipleRingBuffer <- function(inputPolygon, maxDistance, interval) 
{
  #create a list of distances that we'll iterate through to create each ring
  distances <- seq(0, maxDistance, interval)
  #we'll start with the second value in that list - the first is '0'
  distancesCounter <- 2
  #total number of rings we're going to create
  numberOfRings <- floor(maxDistance / interval)
  #a counter of number of rings
  numberOfRingsCounter <- 1
  #initialize an otuput data frame (that is not an sf)
  allRings <- data.frame()
  
  #while number of rings  counteris less than the specified nubmer of rings
  while (numberOfRingsCounter <= numberOfRings) 
  {
    #if we're interested in a negative buffer and this is the first buffer
    #(ie. not distance = '0' in the distances list)
    if(distances[distancesCounter] < 0 & distancesCounter == 2)
    {
      #buffer the input by the first distance
      buffer1 <- st_buffer(inputPolygon, distances[distancesCounter])
      #different that buffer from the input polygon to get the first ring
      buffer1_ <- st_difference(inputPolygon, buffer1)
      #cast this sf as a polygon geometry type
      thisRing <- st_cast(buffer1_, "POLYGON")
      #take the last column which is 'geometry'
      thisRing <- as.data.frame(thisRing[,ncol(thisRing)])
      #add a new field, 'distance' so we know how far the distance is for a give ring
      thisRing$distance <- distances[distancesCounter]
    }
    
    
    #otherwise, if this is the second or more ring (and a negative buffer)
    else if(distances[distancesCounter] < 0 & distancesCounter > 2) 
    {
      #buffer by a specific distance
      buffer1 <- st_buffer(inputPolygon, distances[distancesCounter])
      #create the next smallest buffer
      buffer2 <- st_buffer(inputPolygon, distances[distancesCounter-1])
      #This can then be used to difference out a buffer running from 660 to 1320
      #This works because differencing 1320ft by 660ft = a buffer between 660 & 1320.
      #bc the area after 660ft in buffer2 = NA.
      thisRing <- st_difference(buffer2,buffer1)
      #cast as apolygon
      thisRing <- st_cast(thisRing, "POLYGON")
      #get the last field
      thisRing <- as.data.frame(thisRing$geometry)
      #create the distance field
      thisRing$distance <- distances[distancesCounter]
    }
    
    #Otherwise, if its a positive buffer
    else 
    {
      #Create a positive buffer
      buffer1 <- st_buffer(inputPolygon, distances[distancesCounter])
      #create a positive buffer that is one distance smaller. So if its the first buffer
      #distance, buffer1_ will = 0. 
      buffer1_ <- st_buffer(inputPolygon, distances[distancesCounter-1])
      #difference the two buffers
      thisRing <- st_difference(buffer1,buffer1_)
      #cast as a polygon
      thisRing <- st_cast(thisRing, "POLYGON")
      #geometry column as a data frame
      thisRing <- as.data.frame(thisRing[,ncol(thisRing)])
      #add teh distance
      thisRing$distance <- distances[distancesCounter]
    }  
    
    #rbind this ring to the rest of the rings
    allRings <- rbind(allRings, thisRing)
    #iterate the distance counter
    distancesCounter <- distancesCounter + 1
    #iterate the number of rings counter
    numberOfRingsCounter <- numberOfRingsCounter + 1
  }
  
  #convert the allRings data frame to an sf data frame
  allRings <- st_as_sf(allRings)
}
```

```{r}
coolRingBuffer <- multipleRingBuffer(st_union(metroStops), 37830, 2640)

ggplot(coolRingBuffer) + 
  geom_sf(data=coolRingBuffer, 
          aes(colour = distance), 
          show.legend = "polygon", size= 2) +
  scale_colour_gradient() +
	geom_sf(data=st_union(cleanTracts00), fill="transparent", color="red",size =1) +
  labs(title="Metro Stops", 
       subtitle="District of Columbia", 
       caption="Figure 1: Washington DC Metro Station locations, colored by Metro Line") +
  mapTheme()
		
```
	
	
```{r}
# Use multipleRingBuffer to draw regions around the metro stops
# Then join the census data (containing rent data) to those rings
allTracts.rings <-
  st_join(st_centroid(dplyr::select(allTracts, GEOID, year)), 
          multipleRingBuffer(st_union(metroStops), 37830, 2640)) %>%
  st_drop_geometry() %>%
  left_join(dplyr::select(allTracts, GEOID, MedRent, year), 
            by=c("GEOID"="GEOID", "year"="year")) %>%
  st_sf() %>%
  mutate(distance = distance / 5280) #convert to miles

# Lets clean up the data so we can visualize it as a line graph
# We need to get rid of the geometry, group by year and distance
# and then summarize the rents found at each level (calculate avg)
allTracts.rings.summary <-
	allTracts.rings %>%
	st_drop_geometry() %>%
	group_by(distance, year) %>%
	summarize(Rent = mean(MedRent, na.rm = TRUE)) %>%
	mutate(Rent = round(Rent, 2))

# Now let's visualize it
ggplot(allTracts.rings.summary,
			 aes(x =distance, y=Rent, color=year)) +
	geom_line() +
	geom_point()
```

# Trends in Crime, Transit, and Rent

#### Load and clean crime data
```{r}
# 2010 crime data (earliest available, is 2008, but use 2010 for decenial census)
crime10 <- st_read("https://opendata.arcgis.com/datasets/fdacfbdda7654e06a161352247d3a2f0_34.geojson") %>%
	st_transform('ESRI:102746') %>%
	filter(grepl('THEFT',OFFENSE)) %>%
	mutate(crimeYear = "2010") %>%
	dplyr::select(OFFENSE,crimeYear)

# 2017 crime data (consistent with upper end of census data we are analyzing)
crime17 <- st_read("https://opendata.arcgis.com/datasets/6af5cb8dc38e4bcbac8168b27ee104aa_38.geojson") %>%
	st_transform('ESRI:102746') %>%
	filter(grepl('THEFT',OFFENSE)) %>%
	mutate(crimeYear = "2017") %>%
	dplyr::select(OFFENSE,crimeYear) #%>%
	# dplyr::select(-geometry)

# Place all crime data in same df
allCrime <- rbind(crime10, crime17)
allCrime <- mutate(allCrime, crimeCounter = 1)
	
```


```{r}
# Intersect crimes with the station buffer/census tract polygons we already created
crime_station_tracts <- st_intersection(allCrime, station_tracts)

# Lets summarize those data so we can join it back to the station points and visualize it
crime_station_summary <-
	crime_station_tracts %>%
	st_drop_geometry() %>%
	group_by(crimeYear, GIS_ID) %>%
	summarize(Population = sum(TotalPop),
						Rent = mean(MedRent, na.rm = T),
						Crime = sum(crimeCounter)
						) %>%
	filter()

# Complete the join of the summarized data to the station points
crime_station_GeoSummary <-
	left_join(metroStops, crime_station_summary, by = "GIS_ID") %>%
	dplyr::select(-WEB_URL, -TRAININFO_URL)

```


```{r}
# Now that we have the data ready, lets visualize it
# Graduated Symbols map visualizing population
ggplot(crime_station_GeoSummary) +
	geom_sf(data = allTracts)+
	geom_sf(aes(size = Population), color = "#7bccc4", ) +
	facet_wrap(~year) +
	mapTheme()

# Graduated Symbols map visualizing rent
ggplot(crime_station_GeoSummary) +
	geom_sf(data = allTracts)+
	geom_sf(aes(size = Rent), color = "#43a2ca", ) +
	facet_wrap(~year) +
	mapTheme()

# Graduated Symbols map visualizing crime 
ggplot(crime_station_GeoSummary) +
	geom_sf(data = allTracts)+
	geom_sf(aes(size = Crime), color = "#0868ac", ) +
	facet_wrap(~year) +
	mapTheme()

```


